-- MySQL Script generated by MySQL Workbench
-- Fri Apr 25 13:19:30 2025
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema mydb
-- -----------------------------------------------------

-- -----------------------------------------------------
-- Schema mydb
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `mydb` DEFAULT CHARACTER SET utf8mb3 ;
USE `mydb` ;

-- -----------------------------------------------------
-- Table `mydb`.`companies`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`companies` (
  `company_id` INT NOT NULL AUTO_INCREMENT,
  `company_name` VARCHAR(45) NOT NULL,
  `industry` VARCHAR(45) NULL DEFAULT NULL,
  `headquarters` VARCHAR(45) NULL DEFAULT NULL,
  PRIMARY KEY (`company_id`),
  UNIQUE INDEX `company_name_UNIQUE` (`company_name` ASC) VISIBLE)
ENGINE = InnoDB
AUTO_INCREMENT = 16
DEFAULT CHARACTER SET = utf8mb3;


-- -----------------------------------------------------
-- Table `mydb`.`snapshot_metadata`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`snapshot_metadata` (
  `snapshot_id` INT NOT NULL AUTO_INCREMENT,
  `snapshot_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`snapshot_id`))
ENGINE = InnoDB
AUTO_INCREMENT = 2
DEFAULT CHARACTER SET = utf8mb3;


-- -----------------------------------------------------
-- Table `mydb`.`traders`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`traders` (
  `trader_id` INT NOT NULL AUTO_INCREMENT,
  `trader_name` VARCHAR(45) NOT NULL,
  `email` VARCHAR(45) NULL DEFAULT NULL,
  `balance` FLOAT NOT NULL DEFAULT '0',
  PRIMARY KEY (`trader_id`),
  UNIQUE INDEX `trader_name_UNIQUE` (`trader_name` ASC) VISIBLE)
ENGINE = InnoDB
AUTO_INCREMENT = 12
DEFAULT CHARACTER SET = utf8mb3;


-- -----------------------------------------------------
-- Table `mydb`.`stocks`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`stocks` (
  `ticker` VARCHAR(10) NOT NULL,
  `company_id` INT NOT NULL,
  `total_shares` INT NOT NULL,
  PRIMARY KEY (`ticker`),
  UNIQUE INDEX `ticker_UNIQUE` (`ticker` ASC) VISIBLE,
  INDEX `company_id_idx` (`company_id` ASC) VISIBLE,
  CONSTRAINT `company_id`
    FOREIGN KEY (`company_id`)
    REFERENCES `mydb`.`companies` (`company_id`)
    ON DELETE RESTRICT)
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8mb3;


-- -----------------------------------------------------
-- Table `mydb`.`holdings_history`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`holdings_history` (
  `snapshot_id` INT NOT NULL,
  `trader_id` INT NOT NULL,
  `ticker` VARCHAR(10) NOT NULL,
  `quantity` INT NOT NULL,
  INDEX `snapshot_id` (`snapshot_id` ASC) VISIBLE,
  INDEX `trader_id` (`trader_id` ASC) VISIBLE,
  INDEX `ticker` (`ticker` ASC) VISIBLE,
  CONSTRAINT `holdings_history_ibfk_1`
    FOREIGN KEY (`snapshot_id`)
    REFERENCES `mydb`.`snapshot_metadata` (`snapshot_id`)
    ON DELETE RESTRICT,
  CONSTRAINT `holdings_history_ibfk_2`
    FOREIGN KEY (`trader_id`)
    REFERENCES `mydb`.`traders` (`trader_id`)
    ON DELETE RESTRICT,
  CONSTRAINT `holdings_history_ibfk_3`
    FOREIGN KEY (`ticker`)
    REFERENCES `mydb`.`stocks` (`ticker`)
    ON DELETE RESTRICT)
ENGINE = InnoDB
DEFAULT CHARACTER SET = utf8mb3;


-- -----------------------------------------------------
-- Table `mydb`.`orders`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`orders` (
  `order_id` INT NOT NULL AUTO_INCREMENT,
  `ticker` VARCHAR(10) NOT NULL,
  `trader_id` INT NOT NULL,
  `order_type` ENUM('BUY', 'SELL') NOT NULL,
  `quantity` INT NOT NULL,
  `price` FLOAT NOT NULL,
  `status` ENUM('OPEN', 'PARTIALLY_FILLED', 'FILLED', 'ISSUED') NOT NULL,
  `order_date` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`order_id`),
  INDEX `trader_id_idx` (`trader_id` ASC) VISIBLE,
  INDEX `fk_orders_ticker` (`ticker` ASC) VISIBLE,
  CONSTRAINT `fk_orders_ticker`
    FOREIGN KEY (`ticker`)
    REFERENCES `mydb`.`stocks` (`ticker`),
  CONSTRAINT `trader_id`
    FOREIGN KEY (`trader_id`)
    REFERENCES `mydb`.`traders` (`trader_id`)
    ON DELETE RESTRICT)
ENGINE = InnoDB
AUTO_INCREMENT = 301
DEFAULT CHARACTER SET = utf8mb3;


-- -----------------------------------------------------
-- Table `mydb`.`transactions`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`transactions` (
  `transaction_id` INT NOT NULL AUTO_INCREMENT,
  `order_id` INT NOT NULL,
  `quantity` INT NOT NULL,
  `price_per_share` FLOAT NOT NULL,
  `transaction_type` ENUM('BUY', 'SELL', 'ISSUE') NOT NULL,
  `transaction_date` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`transaction_id`),
  INDEX `order_id_idx` (`order_id` ASC) VISIBLE,
  CONSTRAINT `order_id`
    FOREIGN KEY (`order_id`)
    REFERENCES `mydb`.`orders` (`order_id`)
    ON DELETE RESTRICT)
ENGINE = InnoDB
AUTO_INCREMENT = 376
DEFAULT CHARACTER SET = utf8mb3;

USE `mydb` ;

-- -----------------------------------------------------
-- Placeholder table for view `mydb`.`current_holdings`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mydb`.`current_holdings` (`trader_id` INT, `ticker` INT, `quantity` INT);

-- -----------------------------------------------------
-- procedure BuyStock
-- -----------------------------------------------------

DELIMITER $$
USE `mydb`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `BuyStock`(
  IN p_trader_id INT,
  IN p_ticker VARCHAR(10),
  IN p_quantity INT,
  IN p_max_price FLOAT
)
BEGIN
  DECLARE v_buy_order_id INT;
  DECLARE v_remaining_to_buy INT;
  DECLARE v_seller_order_id INT;
  DECLARE v_seller_id INT;
  DECLARE v_sell_price FLOAT;
  DECLARE v_seller_filled INT;
  DECLARE v_seller_order_quantity INT;
  DECLARE v_to_transfer INT;

  START TRANSACTION;

  -- Insert the BUY order
  INSERT INTO Orders (
    ticker, trader_id, order_type, quantity, price, status, order_date
  ) VALUES (
    p_ticker, p_trader_id, 'BUY', p_quantity, p_max_price, 'OPEN', CURRENT_TIMESTAMP
  );

  SET v_buy_order_id = LAST_INSERT_ID();
  SET v_remaining_to_buy = p_quantity;

  -- Try to match against open SELL orders
  WHILE_LOOP: WHILE v_remaining_to_buy > 0 DO
    SELECT o.order_id, o.trader_id, o.price, o.quantity,
           IFNULL(SUM(t.quantity), 0) AS filled_quantity
    INTO v_seller_order_id, v_seller_id, v_sell_price, v_seller_order_quantity, v_seller_filled
    FROM Orders o
    LEFT JOIN Transactions t ON o.order_id = t.order_id
    WHERE o.ticker = p_ticker
      AND o.order_type = 'SELL'
      AND o.status IN ('OPEN', 'PARTIALLY_FILLED')
      AND o.price <= p_max_price
    GROUP BY o.order_id
    ORDER BY o.price ASC, o.order_date ASC
    LIMIT 1;

    IF v_seller_order_id IS NULL THEN
      LEAVE WHILE_LOOP;
    END IF;

    SET v_to_transfer = LEAST(v_remaining_to_buy, v_seller_order_quantity - v_seller_filled);

    -- Record transactions for both buyer and seller
    INSERT INTO Transactions (order_id, quantity, price_per_share, transaction_type, transaction_date)
    VALUES 
      (v_buy_order_id, v_to_transfer, v_sell_price, 'BUY', CURRENT_TIMESTAMP),
      (v_seller_order_id, v_to_transfer, v_sell_price, 'SELL', CURRENT_TIMESTAMP);

    -- Update SELL order status
    UPDATE Orders
    SET status = CASE
      WHEN (v_seller_filled + v_to_transfer) = v_seller_order_quantity THEN 'FILLED'
      ELSE 'PARTIALLY_FILLED'
    END
    WHERE order_id = v_seller_order_id;

    SET v_remaining_to_buy = v_remaining_to_buy - v_to_transfer;
  END WHILE;

  -- Update BUY order status
  UPDATE Orders
  SET status = CASE
    WHEN v_remaining_to_buy = p_quantity THEN 'OPEN'
    WHEN v_remaining_to_buy = 0 THEN 'FILLED'
    ELSE 'PARTIALLY_FILLED'
  END

  
  WHERE order_id = v_buy_order_id;

  COMMIT;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure IssueInitialShares
-- -----------------------------------------------------

DELIMITER $$
USE `mydb`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `IssueInitialShares`(
  IN p_ticker VARCHAR(10),
  IN p_quantity INT
)
BEGIN
  DECLARE v_order_id INT;

  -- Insert a fake "BUY" order to grant SystemIssuer ownership
  INSERT INTO orders (
    ticker, trader_id, order_type, quantity, price, status, order_date
  ) VALUES (
    p_ticker, 1, 'BUY', p_quantity, 0.00, 'ISSUED', CURRENT_TIMESTAMP
  );

  SET v_order_id = LAST_INSERT_ID();

  -- Insert a fake transaction to reflect the issued shares
  INSERT INTO transactions (
    order_id, quantity, price_per_share, transaction_type, transaction_date
  ) VALUES (
    v_order_id, p_quantity, 0.00, 'BUY', CURRENT_TIMESTAMP
  );
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure SellStock
-- -----------------------------------------------------

DELIMITER $$
USE `mydb`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `SellStock`(
  IN p_trader_id INT,
  IN p_ticker VARCHAR(10),
  IN p_quantity INT,
  IN p_min_price FLOAT
)
BEGIN
  DECLARE v_sell_order_id INT;
  DECLARE v_remaining_to_sell INT;
  DECLARE v_buyer_order_id INT;
  DECLARE v_buyer_id INT;
  DECLARE v_buyer_price FLOAT;
  DECLARE v_buyer_filled INT;
  DECLARE v_buyer_order_quantity INT;
  DECLARE v_to_transfer INT;
  DECLARE v_current_quantity INT;

  START TRANSACTION;

  -- Check if the trader has enough holdings using the view
  SELECT quantity INTO v_current_quantity
  FROM current_holdings
  WHERE trader_id = p_trader_id AND ticker = p_ticker;

  IF v_current_quantity >= p_quantity THEN
    -- Insert the SELL order
    INSERT INTO Orders (
      ticker, trader_id, order_type, quantity, price, status, order_date
    ) VALUES (
      p_ticker, p_trader_id, 'SELL', p_quantity, p_min_price, 'OPEN', CURRENT_TIMESTAMP
    );

    SET v_sell_order_id = LAST_INSERT_ID();
    SET v_remaining_to_sell = p_quantity;

    -- Try to match against open BUY orders
    WHILE_LOOP: WHILE v_remaining_to_sell > 0 DO
      SELECT o.order_id, o.trader_id, o.price, o.quantity,
             IFNULL(SUM(t.quantity), 0) AS filled_quantity
      INTO v_buyer_order_id, v_buyer_id, v_buyer_price, v_buyer_order_quantity, v_buyer_filled
      FROM Orders o
      LEFT JOIN Transactions t ON o.order_id = t.order_id
      WHERE o.ticker = p_ticker
        AND o.order_type = 'BUY'
        AND o.status IN ('OPEN', 'PARTIALLY_FILLED')
        AND o.price >= p_min_price
      GROUP BY o.order_id
      ORDER BY o.price DESC, o.order_date ASC
      LIMIT 1;

      IF v_buyer_order_id IS NULL THEN
        LEAVE WHILE_LOOP;
      END IF;

      SET v_to_transfer = LEAST(v_remaining_to_sell, v_buyer_order_quantity - v_buyer_filled);

      -- Record transactions for both buyer and seller
      INSERT INTO Transactions (order_id, quantity, price_per_share, transaction_type, transaction_date)
      VALUES 
        (v_buyer_order_id, v_to_transfer, v_buyer_price, 'BUY', CURRENT_TIMESTAMP),
        (v_sell_order_id, v_to_transfer, v_buyer_price, 'SELL', CURRENT_TIMESTAMP);

      -- Update BUY order status
      UPDATE Orders
      SET status = CASE
        WHEN (v_buyer_filled + v_to_transfer) = v_buyer_order_quantity THEN 'FILLED'
        ELSE 'PARTIALLY_FILLED'
      END
      WHERE order_id = v_buyer_order_id;

      SET v_remaining_to_sell = v_remaining_to_sell - v_to_transfer;
    END WHILE;

    -- Update SELL order status
    UPDATE Orders
    SET status = CASE
	  WHEN v_remaining_to_sell = p_quantity THEN 'OPEN'
      WHEN v_remaining_to_sell = 0 THEN 'FILLED'
      ELSE 'PARTIALLY_FILLED'
    END
    WHERE order_id = v_sell_order_id;

    COMMIT;
  ELSE
    ROLLBACK;
  END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure TakeHoldingsSnapshot
-- -----------------------------------------------------

DELIMITER $$
USE `mydb`$$
CREATE DEFINER=`root`@`localhost` PROCEDURE `TakeHoldingsSnapshot`()
BEGIN
  DECLARE v_snapshot_id INT;

  -- Step 1: Insert new snapshot metadata
  INSERT INTO snapshot_metadata () VALUES ();
  SET v_snapshot_id = LAST_INSERT_ID();

  -- Step 2: Insert current holdings into history
  INSERT INTO holdings_history (snapshot_id, trader_id, ticker, quantity)
  SELECT v_snapshot_id, trader_id, ticker, quantity
  FROM current_holdings;

END$$

DELIMITER ;

-- -----------------------------------------------------
-- function format_big_number
-- -----------------------------------------------------

DELIMITER $$
USE `mydb`$$
CREATE DEFINER=`root`@`localhost` FUNCTION `format_big_number`(val DOUBLE) RETURNS varchar(20) CHARSET utf8mb3
    DETERMINISTIC
BEGIN
  RETURN CASE
    WHEN val >= 1000000000 THEN CONCAT(ROUND(val / 1000000000, 2), 'B')
    WHEN val >= 1000000 THEN CONCAT(ROUND(val / 1000000, 2), 'M')
    WHEN val >= 1000 THEN CONCAT(ROUND(val / 1000, 2), 'K')
    ELSE ROUND(val, 2)
  END;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- function get_last_price
-- -----------------------------------------------------

DELIMITER $$
USE `mydb`$$
CREATE DEFINER=`root`@`localhost` FUNCTION `get_last_price`(p_ticker VARCHAR(10)) RETURNS float
    DETERMINISTIC
BEGIN
  DECLARE v_price FLOAT;

  SELECT t.price_per_share
  INTO v_price
  FROM Transactions t
  JOIN Orders o ON t.order_id = o.order_id
  WHERE o.ticker = p_ticker
  ORDER BY t.transaction_date DESC, t.transaction_id DESC
  LIMIT 1;

  RETURN v_price;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- View `mydb`.`current_holdings`
-- -----------------------------------------------------
DROP TABLE IF EXISTS `mydb`.`current_holdings`;
USE `mydb`;
CREATE  OR REPLACE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `mydb`.`current_holdings` AS select `o`.`trader_id` AS `trader_id`,`o`.`ticker` AS `ticker`,sum((case `t`.`transaction_type` when 'BUY' then `t`.`quantity` when 'SELL' then -(`t`.`quantity`) end)) AS `quantity` from (`mydb`.`transactions` `t` join `mydb`.`orders` `o` on((`t`.`order_id` = `o`.`order_id`))) group by `o`.`trader_id`,`o`.`ticker` having (`quantity` > 0);

SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;
